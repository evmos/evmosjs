import { decodeSignDocToTypedData, hashEIP712 } from './encoding'

// Testing Constants
const eip712Domain = {
  name: 'Cosmos Web3',
  version: '1.0.0',
  chainId: 9000,
  verifyingContract: 'cosmos',
  salt: '0',
}
const eip712PrimaryType = 'Tx'

describe('encoding', () => {
  it('decodes amino signdocs', () => {
    const byteString =
      '123 34 97 99 99 111 117 110 116 95 110 117 109 98 101 114 34 58 34 48 34 44 34 99 104 97 105 110 95 105 100 34 58 34 101 118 109 111 115 95 57 48 48 48 45 49 34 44 34 102 101 101 34 58 123 34 97 109 111 117 110 116 34 58 91 123 34 97 109 111 117 110 116 34 58 34 50 48 48 34 44 34 100 101 110 111 109 34 58 34 97 101 118 109 111 115 34 125 93 44 34 103 97 115 34 58 34 50 48 48 48 48 48 34 125 44 34 109 101 109 111 34 58 34 34 44 34 109 115 103 115 34 58 91 123 34 116 121 112 101 34 58 34 99 111 115 109 111 115 45 115 100 107 47 77 115 103 83 101 110 100 34 44 34 118 97 108 117 101 34 58 123 34 97 109 111 117 110 116 34 58 91 123 34 97 109 111 117 110 116 34 58 34 49 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 34 44 34 100 101 110 111 109 34 58 34 97 101 118 109 111 115 34 125 93 44 34 102 114 111 109 95 97 100 100 114 101 115 115 34 58 34 101 118 109 111 115 49 119 115 97 117 114 112 121 55 117 120 109 50 110 56 118 102 103 103 99 57 101 104 112 106 108 122 109 102 115 115 120 51 48 53 97 119 120 120 34 44 34 116 111 95 97 100 100 114 101 115 115 34 58 34 101 118 109 111 115 49 104 110 109 114 100 114 48 106 99 50 118 101 51 121 99 120 102 116 48 103 99 106 106 116 114 100 107 110 99 112 109 109 107 101 97 109 102 57 34 125 125 93 44 34 115 101 113 117 101 110 99 101 34 58 34 49 34 125'
    const bytes = Uint8Array.from(byteString.split(' ').map((el) => Number(el)))

    expect(() => {
      decodeSignDocToTypedData(bytes)
    }).not.toThrow(Error)
  })

  it('decodes protobuf signdocs', () => {
    const byteString =
      '10 157 1 10 154 1 10 28 47 99 111 115 109 111 115 46 98 97 110 107 46 118 49 98 101 116 97 49 46 77 115 103 83 101 110 100 18 122 10 44 101 118 109 111 115 49 116 121 118 112 113 53 55 51 54 108 122 106 50 121 122 109 106 48 107 97 110 113 120 103 55 119 102 50 57 102 109 112 50 100 114 113 116 48 18 44 101 118 109 111 115 49 104 110 109 114 100 114 48 106 99 50 118 101 51 121 99 120 102 116 48 103 99 106 106 116 114 100 107 110 99 112 109 109 107 101 97 109 102 57 26 28 10 6 97 101 118 109 111 115 18 18 49 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 18 112 10 89 10 79 10 40 47 101 116 104 101 114 109 105 110 116 46 99 114 121 112 116 111 46 118 49 46 101 116 104 115 101 99 112 50 53 54 107 49 46 80 117 98 75 101 121 18 35 10 33 3 49 50 222 101 16 162 111 232 18 113 67 108 229 229 56 46 213 147 92 122 233 142 164 59 1 106 220 154 240 182 35 139 18 4 10 2 8 1 24 1 18 19 10 13 10 6 97 101 118 109 111 115 18 3 50 48 48 16 192 154 12 26 12 101 118 109 111 115 95 57 48 48 48 45 49'
    const bytes = Uint8Array.from(byteString.split(' ').map((el) => Number(el)))

    expect(() => {
      decodeSignDocToTypedData(bytes)
    }).not.toThrow(Error)
  })

  it('throws decoding invalid payload', () => {
    const byteString =
      '157 1 10 154 1 10 28 47 99 111 115 109 111 115 46 98 97 110 107 46 118 49 98 101 116 97 49 46 77 115 103 83 101 110 100 18 122 10 44 101 118 109 111 115 49 116 121 118 112 113 53 55 51 54 108 122 106 50 121 122 109 106 48 107 97 110 113 120 103 55 119 102 50 57 102 109 112 50 100 114 113 116 48 18 44 101 118 109 111 115 49 104 110 109 114 100 114 48 106 99 50 118 101 51 121 99 120 102 116 48 103 99 106 106 116 114 100 107 110 99 112 109 109 107 101 97 109 102 57 26 28 10 6 97 101 118 109 111 115 18 18 49 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 18 112 10 89 10 79 10 40 47 101 116 104 101 114 109 105 110 116 46 99 114 121 112 116 111 46 118 49 46 101 116 104 115 101 99 112 50 53 54 107 49 46 80 117 98 75 101 121 18 35 10 33 3 49 50 222 101 16 162 111 232 18 113 67 108 229 229 56 46 213 147 92 122 233 142 164 59 1 106 220 154 240 182 35 139 18 4 10 2 8 1 24 1 18 19 10 13 10 6 97 101 118 109 111 115 18 3 50 48 48 16 192 154 12 26 12 101 118 109 111 115 95 57 48 48 48 45 49'
    const bytes = Uint8Array.from(byteString.split(' ').map((el) => Number(el)))

    expect(() => {
      decodeSignDocToTypedData(bytes)
    }).toThrow(Error)
  })

  it('hashes eip712 structs 0', () => {
    // Amino MSG_VOTE
    const byteString =
      '123 34 97 99 99 111 117 110 116 95 110 117 109 98 101 114 34 58 34 48 34 44 34 99 104 97 105 110 95 105 100 34 58 34 101 118 109 111 115 95 57 48 48 48 45 49 34 44 34 102 101 101 34 58 123 34 97 109 111 117 110 116 34 58 91 123 34 97 109 111 117 110 116 34 58 34 50 48 48 48 34 44 34 100 101 110 111 109 34 58 34 97 101 118 109 111 115 34 125 93 44 34 103 97 115 34 58 34 50 48 48 48 48 48 34 125 44 34 109 101 109 111 34 58 34 34 44 34 109 115 103 115 34 58 91 123 34 116 121 112 101 34 58 34 99 111 115 109 111 115 45 115 100 107 47 77 115 103 86 111 116 101 34 44 34 118 97 108 117 101 34 58 123 34 111 112 116 105 111 110 34 58 49 44 34 112 114 111 112 111 115 97 108 95 105 100 34 58 34 49 34 44 34 118 111 116 101 114 34 58 34 101 118 109 111 115 49 121 103 120 113 50 53 118 108 112 51 117 52 108 113 121 121 115 54 118 114 115 100 97 122 57 119 119 57 107 103 114 120 55 120 108 104 116 121 34 125 125 93 44 34 115 101 113 117 101 110 99 101 34 58 34 49 34 125'
    const bytes = Uint8Array.from(byteString.split(' ').map((el) => Number(el)))
    const eip712 = decodeSignDocToTypedData(bytes)
    const { domain, message } = hashEIP712(eip712)
    expect(Buffer.from(domain).toString('hex')).toBe(
      '18a89ea35edd8815ce767aaabc09a316b4fbc08f3201680390a31f7da513f3ec',
    )
    expect(Buffer.from(message).toString('hex')).toBe(
      'ab08501e02408252b4f674263d976f2995feb4bb8127b393baf75c54cfd86d76',
    )
  })

  it('hashes eip712 structs 1', () => {
    // Protobuf MSG_SEND
    const byteString =
      '10 157 1 10 154 1 10 28 47 99 111 115 109 111 115 46 98 97 110 107 46 118 49 98 101 116 97 49 46 77 115 103 83 101 110 100 18 122 10 44 101 118 109 111 115 49 116 121 118 112 113 53 55 51 54 108 122 106 50 121 122 109 106 48 107 97 110 113 120 103 55 119 102 50 57 102 109 112 50 100 114 113 116 48 18 44 101 118 109 111 115 49 104 110 109 114 100 114 48 106 99 50 118 101 51 121 99 120 102 116 48 103 99 106 106 116 114 100 107 110 99 112 109 109 107 101 97 109 102 57 26 28 10 6 97 101 118 109 111 115 18 18 49 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 18 112 10 89 10 79 10 40 47 101 116 104 101 114 109 105 110 116 46 99 114 121 112 116 111 46 118 49 46 101 116 104 115 101 99 112 50 53 54 107 49 46 80 117 98 75 101 121 18 35 10 33 3 49 50 222 101 16 162 111 232 18 113 67 108 229 229 56 46 213 147 92 122 233 142 164 59 1 106 220 154 240 182 35 139 18 4 10 2 8 1 24 1 18 19 10 13 10 6 97 101 118 109 111 115 18 3 50 48 48 16 192 154 12 26 12 101 118 109 111 115 95 57 48 48 48 45 49'
    const bytes = Uint8Array.from(byteString.split(' ').map((el) => Number(el)))
    const eip712 = decodeSignDocToTypedData(bytes)
    const { domain, message } = hashEIP712(eip712)
    expect(Buffer.from(domain).toString('hex')).toBe(
      '18a89ea35edd8815ce767aaabc09a316b4fbc08f3201680390a31f7da513f3ec',
    )
    expect(Buffer.from(message).toString('hex')).toBe(
      'a6a4e73512097abdf92fa255904b317eb37b727de8513d03877df4671e033e88',
    )
  })

  it('throws hashing invalid eip712', () => {
    const invalidEip712 = {
      domain: eip712Domain,
      primaryType: eip712PrimaryType,
      types: {
        EIP712Domain: 'invalid format',
      },
      message: {
        recipient: 'content',
      },
    }

    expect(() => {
      hashEIP712(invalidEip712)
    }).toThrow(Error)
  })
})
