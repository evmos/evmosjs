// @ts-nocheck
/* eslint-disable */
/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.4
 * source: cosmos/tx/signing/v1beta1/signing.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../../crypto/multisig/v1beta1/multisig";
import * as dependency_2 from "./../../../../google/protobuf/any";
import * as pb_1 from "google-protobuf";
export namespace cosmos.tx.signing.v1beta1 {
    export enum SignMode {
        SIGN_MODE_UNSPECIFIED = 0,
        SIGN_MODE_DIRECT = 1,
        SIGN_MODE_TEXTUAL = 2,
        SIGN_MODE_LEGACY_AMINO_JSON = 127
    }
    export class SignatureDescriptors extends pb_1.Message {
        constructor(data?: any[] | {
            signatures?: SignatureDescriptor[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("signatures" in data && data.signatures != undefined) {
                    this.signatures = data.signatures;
                }
            }
        }
        get signatures() {
            return pb_1.Message.getRepeatedWrapperField(this, SignatureDescriptor, 1) as SignatureDescriptor[];
        }
        set signatures(value: SignatureDescriptor[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            signatures?: ReturnType<typeof SignatureDescriptor.prototype.toObject>[];
        }) {
            const message = new SignatureDescriptors({});
            if (data.signatures != null) {
                message.signatures = data.signatures.map(item => SignatureDescriptor.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                signatures?: ReturnType<typeof SignatureDescriptor.prototype.toObject>[];
            } = {};
            if (this.signatures != null) {
                data.signatures = this.signatures.map((item: SignatureDescriptor) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.signatures !== undefined)
                writer.writeRepeatedMessage(1, this.signatures, (item: SignatureDescriptor) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignatureDescriptors {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignatureDescriptors();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.signatures, () => pb_1.Message.addToRepeatedWrapperField(message, 1, SignatureDescriptor.deserialize(reader), SignatureDescriptor));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignatureDescriptors {
            return SignatureDescriptors.deserialize(bytes);
        }
    }
    export class SignatureDescriptor extends pb_1.Message {
        constructor(data?: any[] | {
            public_key?: dependency_2.google.protobuf.Any;
            data?: SignatureDescriptor.Data;
            sequence?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("public_key" in data && data.public_key != undefined) {
                    this.public_key = data.public_key;
                }
                if ("data" in data && data.data != undefined) {
                    this.data = data.data;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
            }
        }
        get public_key() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Any, 1) as dependency_2.google.protobuf.Any;
        }
        set public_key(value: dependency_2.google.protobuf.Any) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get data() {
            return pb_1.Message.getWrapperField(this, SignatureDescriptor.Data, 2) as SignatureDescriptor.Data;
        }
        set data(value: SignatureDescriptor.Data) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get sequence() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            public_key?: ReturnType<typeof dependency_2.google.protobuf.Any.prototype.toObject>;
            data?: ReturnType<typeof SignatureDescriptor.Data.prototype.toObject>;
            sequence?: number;
        }) {
            const message = new SignatureDescriptor({});
            if (data.public_key != null) {
                message.public_key = dependency_2.google.protobuf.Any.fromObject(data.public_key);
            }
            if (data.data != null) {
                message.data = SignatureDescriptor.Data.fromObject(data.data);
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            return message;
        }
        toObject() {
            const data: {
                public_key?: ReturnType<typeof dependency_2.google.protobuf.Any.prototype.toObject>;
                data?: ReturnType<typeof SignatureDescriptor.Data.prototype.toObject>;
                sequence?: number;
            } = {};
            if (this.public_key != null) {
                data.public_key = this.public_key.toObject();
            }
            if (this.data != null) {
                data.data = this.data.toObject();
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.public_key !== undefined)
                writer.writeMessage(1, this.public_key, () => this.public_key.serialize(writer));
            if (this.data !== undefined)
                writer.writeMessage(2, this.data, () => this.data.serialize(writer));
            if (this.sequence !== undefined)
                writer.writeUint64(3, this.sequence);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignatureDescriptor {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignatureDescriptor();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.public_key, () => message.public_key = dependency_2.google.protobuf.Any.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.data, () => message.data = SignatureDescriptor.Data.deserialize(reader));
                        break;
                    case 3:
                        message.sequence = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignatureDescriptor {
            return SignatureDescriptor.deserialize(bytes);
        }
    }
    export namespace SignatureDescriptor {
        export class Data extends pb_1.Message {
            constructor(data?: any[] | ({} & (({
                single?: SignatureDescriptor.Data.Single;
                multi?: never;
            } | {
                single?: never;
                multi?: SignatureDescriptor.Data.Multi;
            })))) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1, 2]]);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("single" in data && data.single != undefined) {
                        this.single = data.single;
                    }
                    if ("multi" in data && data.multi != undefined) {
                        this.multi = data.multi;
                    }
                }
            }
            get single() {
                return pb_1.Message.getWrapperField(this, SignatureDescriptor.Data.Single, 1) as SignatureDescriptor.Data.Single;
            }
            set single(value: SignatureDescriptor.Data.Single) {
                pb_1.Message.setOneofWrapperField(this, 1, [1, 2], value);
            }
            get multi() {
                return pb_1.Message.getWrapperField(this, SignatureDescriptor.Data.Multi, 2) as SignatureDescriptor.Data.Multi;
            }
            set multi(value: SignatureDescriptor.Data.Multi) {
                pb_1.Message.setOneofWrapperField(this, 2, [1, 2], value);
            }
            get sum() {
                const cases: {
                    [index: number]: "none" | "single" | "multi";
                } = {
                    0: "none",
                    1: "single",
                    2: "multi"
                };
                return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
            }
            static fromObject(data: {
                single?: ReturnType<typeof SignatureDescriptor.Data.Single.prototype.toObject>;
                multi?: ReturnType<typeof SignatureDescriptor.Data.Multi.prototype.toObject>;
            }) {
                const message = new Data({});
                if (data.single != null) {
                    message.single = SignatureDescriptor.Data.Single.fromObject(data.single);
                }
                if (data.multi != null) {
                    message.multi = SignatureDescriptor.Data.Multi.fromObject(data.multi);
                }
                return message;
            }
            toObject() {
                const data: {
                    single?: ReturnType<typeof SignatureDescriptor.Data.Single.prototype.toObject>;
                    multi?: ReturnType<typeof SignatureDescriptor.Data.Multi.prototype.toObject>;
                } = {};
                if (this.single != null) {
                    data.single = this.single.toObject();
                }
                if (this.multi != null) {
                    data.multi = this.multi.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.single !== undefined)
                    writer.writeMessage(1, this.single, () => this.single.serialize(writer));
                if (this.multi !== undefined)
                    writer.writeMessage(2, this.multi, () => this.multi.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Data();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.single, () => message.single = SignatureDescriptor.Data.Single.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.multi, () => message.multi = SignatureDescriptor.Data.Multi.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Data {
                return Data.deserialize(bytes);
            }
        }
        export namespace Data {
            export class Single extends pb_1.Message {
                constructor(data?: any[] | {
                    mode?: SignMode;
                    signature?: Uint8Array;
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("mode" in data && data.mode != undefined) {
                            this.mode = data.mode;
                        }
                        if ("signature" in data && data.signature != undefined) {
                            this.signature = data.signature;
                        }
                    }
                }
                get mode() {
                    return pb_1.Message.getField(this, 1) as SignMode;
                }
                set mode(value: SignMode) {
                    pb_1.Message.setField(this, 1, value);
                }
                get signature() {
                    return pb_1.Message.getField(this, 2) as Uint8Array;
                }
                set signature(value: Uint8Array) {
                    pb_1.Message.setField(this, 2, value);
                }
                static fromObject(data: {
                    mode?: SignMode;
                    signature?: Uint8Array;
                }) {
                    const message = new Single({});
                    if (data.mode != null) {
                        message.mode = data.mode;
                    }
                    if (data.signature != null) {
                        message.signature = data.signature;
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        mode?: SignMode;
                        signature?: Uint8Array;
                    } = {};
                    if (this.mode != null) {
                        data.mode = this.mode;
                    }
                    if (this.signature != null) {
                        data.signature = this.signature;
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.mode !== undefined)
                        writer.writeEnum(1, this.mode);
                    if (this.signature !== undefined)
                        writer.writeBytes(2, this.signature);
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Single {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Single();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                message.mode = reader.readEnum();
                                break;
                            case 2:
                                message.signature = reader.readBytes();
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Single {
                    return Single.deserialize(bytes);
                }
            }
            export class Multi extends pb_1.Message {
                constructor(data?: any[] | {
                    bitarray?: dependency_1.cosmos.crypto.multisig.v1beta1.CompactBitArray;
                    signatures?: SignatureDescriptor.Data[];
                }) {
                    super();
                    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
                    if (!Array.isArray(data) && typeof data == "object") {
                        if ("bitarray" in data && data.bitarray != undefined) {
                            this.bitarray = data.bitarray;
                        }
                        if ("signatures" in data && data.signatures != undefined) {
                            this.signatures = data.signatures;
                        }
                    }
                }
                get bitarray() {
                    return pb_1.Message.getWrapperField(this, dependency_1.cosmos.crypto.multisig.v1beta1.CompactBitArray, 1) as dependency_1.cosmos.crypto.multisig.v1beta1.CompactBitArray;
                }
                set bitarray(value: dependency_1.cosmos.crypto.multisig.v1beta1.CompactBitArray) {
                    pb_1.Message.setWrapperField(this, 1, value);
                }
                get signatures() {
                    return pb_1.Message.getRepeatedWrapperField(this, SignatureDescriptor.Data, 2) as SignatureDescriptor.Data[];
                }
                set signatures(value: SignatureDescriptor.Data[]) {
                    pb_1.Message.setRepeatedWrapperField(this, 2, value);
                }
                static fromObject(data: {
                    bitarray?: ReturnType<typeof dependency_1.cosmos.crypto.multisig.v1beta1.CompactBitArray.prototype.toObject>;
                    signatures?: ReturnType<typeof SignatureDescriptor.Data.prototype.toObject>[];
                }) {
                    const message = new Multi({});
                    if (data.bitarray != null) {
                        message.bitarray = dependency_1.cosmos.crypto.multisig.v1beta1.CompactBitArray.fromObject(data.bitarray);
                    }
                    if (data.signatures != null) {
                        message.signatures = data.signatures.map(item => SignatureDescriptor.Data.fromObject(item));
                    }
                    return message;
                }
                toObject() {
                    const data: {
                        bitarray?: ReturnType<typeof dependency_1.cosmos.crypto.multisig.v1beta1.CompactBitArray.prototype.toObject>;
                        signatures?: ReturnType<typeof SignatureDescriptor.Data.prototype.toObject>[];
                    } = {};
                    if (this.bitarray != null) {
                        data.bitarray = this.bitarray.toObject();
                    }
                    if (this.signatures != null) {
                        data.signatures = this.signatures.map((item: SignatureDescriptor.Data) => item.toObject());
                    }
                    return data;
                }
                serialize(): Uint8Array;
                serialize(w: pb_1.BinaryWriter): void;
                serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                    const writer = w || new pb_1.BinaryWriter();
                    if (this.bitarray !== undefined)
                        writer.writeMessage(1, this.bitarray, () => this.bitarray.serialize(writer));
                    if (this.signatures !== undefined)
                        writer.writeRepeatedMessage(2, this.signatures, (item: SignatureDescriptor.Data) => item.serialize(writer));
                    if (!w)
                        return writer.getResultBuffer();
                }
                static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Multi {
                    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Multi();
                    while (reader.nextField()) {
                        if (reader.isEndGroup())
                            break;
                        switch (reader.getFieldNumber()) {
                            case 1:
                                reader.readMessage(message.bitarray, () => message.bitarray = dependency_1.cosmos.crypto.multisig.v1beta1.CompactBitArray.deserialize(reader));
                                break;
                            case 2:
                                reader.readMessage(message.signatures, () => pb_1.Message.addToRepeatedWrapperField(message, 2, SignatureDescriptor.Data.deserialize(reader), SignatureDescriptor.Data));
                                break;
                            default: reader.skipField();
                        }
                    }
                    return message;
                }
                serializeBinary(): Uint8Array {
                    return this.serialize();
                }
                static deserializeBinary(bytes: Uint8Array): Multi {
                    return Multi.deserialize(bytes);
                }
            }
        }
    }
}
