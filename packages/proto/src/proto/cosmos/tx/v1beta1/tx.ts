// @ts-nocheck
/* eslint-disable */
/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.4
 * source: cosmos/tx/v1beta1/tx.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_2 from "./../../crypto/multisig/v1beta1/multisig";
import * as dependency_3 from "./../../base/v1beta1/coin";
import * as dependency_4 from "./../signing/v1beta1/signing";
import * as dependency_5 from "./../../../google/protobuf/any";
import * as pb_1 from "google-protobuf";
export namespace cosmos.tx.v1beta1 {
    export class Tx extends pb_1.Message {
        constructor(data?: any[] | {
            body?: TxBody;
            auth_info?: AuthInfo;
            signatures?: Uint8Array[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("body" in data && data.body != undefined) {
                    this.body = data.body;
                }
                if ("auth_info" in data && data.auth_info != undefined) {
                    this.auth_info = data.auth_info;
                }
                if ("signatures" in data && data.signatures != undefined) {
                    this.signatures = data.signatures;
                }
            }
        }
        get body() {
            return pb_1.Message.getWrapperField(this, TxBody, 1) as TxBody;
        }
        set body(value: TxBody) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get auth_info() {
            return pb_1.Message.getWrapperField(this, AuthInfo, 2) as AuthInfo;
        }
        set auth_info(value: AuthInfo) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get signatures() {
            return pb_1.Message.getField(this, 3) as Uint8Array[];
        }
        set signatures(value: Uint8Array[]) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            body?: ReturnType<typeof TxBody.prototype.toObject>;
            auth_info?: ReturnType<typeof AuthInfo.prototype.toObject>;
            signatures?: Uint8Array[];
        }) {
            const message = new Tx({});
            if (data.body != null) {
                message.body = TxBody.fromObject(data.body);
            }
            if (data.auth_info != null) {
                message.auth_info = AuthInfo.fromObject(data.auth_info);
            }
            if (data.signatures != null) {
                message.signatures = data.signatures;
            }
            return message;
        }
        toObject() {
            const data: {
                body?: ReturnType<typeof TxBody.prototype.toObject>;
                auth_info?: ReturnType<typeof AuthInfo.prototype.toObject>;
                signatures?: Uint8Array[];
            } = {};
            if (this.body != null) {
                data.body = this.body.toObject();
            }
            if (this.auth_info != null) {
                data.auth_info = this.auth_info.toObject();
            }
            if (this.signatures != null) {
                data.signatures = this.signatures;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.body !== undefined)
                writer.writeMessage(1, this.body, () => this.body.serialize(writer));
            if (this.auth_info !== undefined)
                writer.writeMessage(2, this.auth_info, () => this.auth_info.serialize(writer));
            if (this.signatures !== undefined)
                writer.writeRepeatedBytes(3, this.signatures);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tx {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tx();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.body, () => message.body = TxBody.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.auth_info, () => message.auth_info = AuthInfo.deserialize(reader));
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readBytes());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Tx {
            return Tx.deserialize(bytes);
        }
    }
    export class TxRaw extends pb_1.Message {
        constructor(data?: any[] | {
            body_bytes?: Uint8Array;
            auth_info_bytes?: Uint8Array;
            signatures?: Uint8Array[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("body_bytes" in data && data.body_bytes != undefined) {
                    this.body_bytes = data.body_bytes;
                }
                if ("auth_info_bytes" in data && data.auth_info_bytes != undefined) {
                    this.auth_info_bytes = data.auth_info_bytes;
                }
                if ("signatures" in data && data.signatures != undefined) {
                    this.signatures = data.signatures;
                }
            }
        }
        get body_bytes() {
            return pb_1.Message.getField(this, 1) as Uint8Array;
        }
        set body_bytes(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get auth_info_bytes() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set auth_info_bytes(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get signatures() {
            return pb_1.Message.getField(this, 3) as Uint8Array[];
        }
        set signatures(value: Uint8Array[]) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            body_bytes?: Uint8Array;
            auth_info_bytes?: Uint8Array;
            signatures?: Uint8Array[];
        }) {
            const message = new TxRaw({});
            if (data.body_bytes != null) {
                message.body_bytes = data.body_bytes;
            }
            if (data.auth_info_bytes != null) {
                message.auth_info_bytes = data.auth_info_bytes;
            }
            if (data.signatures != null) {
                message.signatures = data.signatures;
            }
            return message;
        }
        toObject() {
            const data: {
                body_bytes?: Uint8Array;
                auth_info_bytes?: Uint8Array;
                signatures?: Uint8Array[];
            } = {};
            if (this.body_bytes != null) {
                data.body_bytes = this.body_bytes;
            }
            if (this.auth_info_bytes != null) {
                data.auth_info_bytes = this.auth_info_bytes;
            }
            if (this.signatures != null) {
                data.signatures = this.signatures;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.body_bytes !== undefined)
                writer.writeBytes(1, this.body_bytes);
            if (this.auth_info_bytes !== undefined)
                writer.writeBytes(2, this.auth_info_bytes);
            if (this.signatures !== undefined)
                writer.writeRepeatedBytes(3, this.signatures);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TxRaw {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TxRaw();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.body_bytes = reader.readBytes();
                        break;
                    case 2:
                        message.auth_info_bytes = reader.readBytes();
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readBytes());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TxRaw {
            return TxRaw.deserialize(bytes);
        }
    }
    export class SignDoc extends pb_1.Message {
        constructor(data?: any[] | {
            body_bytes?: Uint8Array;
            auth_info_bytes?: Uint8Array;
            chain_id?: string;
            account_number?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("body_bytes" in data && data.body_bytes != undefined) {
                    this.body_bytes = data.body_bytes;
                }
                if ("auth_info_bytes" in data && data.auth_info_bytes != undefined) {
                    this.auth_info_bytes = data.auth_info_bytes;
                }
                if ("chain_id" in data && data.chain_id != undefined) {
                    this.chain_id = data.chain_id;
                }
                if ("account_number" in data && data.account_number != undefined) {
                    this.account_number = data.account_number;
                }
            }
        }
        get body_bytes() {
            return pb_1.Message.getField(this, 1) as Uint8Array;
        }
        set body_bytes(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get auth_info_bytes() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set auth_info_bytes(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get chain_id() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set chain_id(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get account_number() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set account_number(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            body_bytes?: Uint8Array;
            auth_info_bytes?: Uint8Array;
            chain_id?: string;
            account_number?: number;
        }) {
            const message = new SignDoc({});
            if (data.body_bytes != null) {
                message.body_bytes = data.body_bytes;
            }
            if (data.auth_info_bytes != null) {
                message.auth_info_bytes = data.auth_info_bytes;
            }
            if (data.chain_id != null) {
                message.chain_id = data.chain_id;
            }
            if (data.account_number != null) {
                message.account_number = data.account_number;
            }
            return message;
        }
        toObject() {
            const data: {
                body_bytes?: Uint8Array;
                auth_info_bytes?: Uint8Array;
                chain_id?: string;
                account_number?: number;
            } = {};
            if (this.body_bytes != null) {
                data.body_bytes = this.body_bytes;
            }
            if (this.auth_info_bytes != null) {
                data.auth_info_bytes = this.auth_info_bytes;
            }
            if (this.chain_id != null) {
                data.chain_id = this.chain_id;
            }
            if (this.account_number != null) {
                data.account_number = this.account_number;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.body_bytes !== undefined)
                writer.writeBytes(1, this.body_bytes);
            if (this.auth_info_bytes !== undefined)
                writer.writeBytes(2, this.auth_info_bytes);
            if (typeof this.chain_id === "string" && this.chain_id.length)
                writer.writeString(3, this.chain_id);
            if (this.account_number !== undefined)
                writer.writeUint64(4, this.account_number);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignDoc {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignDoc();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.body_bytes = reader.readBytes();
                        break;
                    case 2:
                        message.auth_info_bytes = reader.readBytes();
                        break;
                    case 3:
                        message.chain_id = reader.readString();
                        break;
                    case 4:
                        message.account_number = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignDoc {
            return SignDoc.deserialize(bytes);
        }
    }
    export class TxBody extends pb_1.Message {
        constructor(data?: any[] | {
            messages?: dependency_5.google.protobuf.Any[];
            memo?: string;
            timeout_height?: number;
            extension_options?: dependency_5.google.protobuf.Any[];
            non_critical_extension_options?: dependency_5.google.protobuf.Any[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 1023, 2047], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("messages" in data && data.messages != undefined) {
                    this.messages = data.messages;
                }
                if ("memo" in data && data.memo != undefined) {
                    this.memo = data.memo;
                }
                if ("timeout_height" in data && data.timeout_height != undefined) {
                    this.timeout_height = data.timeout_height;
                }
                if ("extension_options" in data && data.extension_options != undefined) {
                    this.extension_options = data.extension_options;
                }
                if ("non_critical_extension_options" in data && data.non_critical_extension_options != undefined) {
                    this.non_critical_extension_options = data.non_critical_extension_options;
                }
            }
        }
        get messages() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_5.google.protobuf.Any, 1) as dependency_5.google.protobuf.Any[];
        }
        set messages(value: dependency_5.google.protobuf.Any[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get memo() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set memo(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get timeout_height() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set timeout_height(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get extension_options() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_5.google.protobuf.Any, 1023) as dependency_5.google.protobuf.Any[];
        }
        set extension_options(value: dependency_5.google.protobuf.Any[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1023, value);
        }
        get non_critical_extension_options() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_5.google.protobuf.Any, 2047) as dependency_5.google.protobuf.Any[];
        }
        set non_critical_extension_options(value: dependency_5.google.protobuf.Any[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2047, value);
        }
        static fromObject(data: {
            messages?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>[];
            memo?: string;
            timeout_height?: number;
            extension_options?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>[];
            non_critical_extension_options?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>[];
        }) {
            const message = new TxBody({});
            if (data.messages != null) {
                message.messages = data.messages.map(item => dependency_5.google.protobuf.Any.fromObject(item));
            }
            if (data.memo != null) {
                message.memo = data.memo;
            }
            if (data.timeout_height != null) {
                message.timeout_height = data.timeout_height;
            }
            if (data.extension_options != null) {
                message.extension_options = data.extension_options.map(item => dependency_5.google.protobuf.Any.fromObject(item));
            }
            if (data.non_critical_extension_options != null) {
                message.non_critical_extension_options = data.non_critical_extension_options.map(item => dependency_5.google.protobuf.Any.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                messages?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>[];
                memo?: string;
                timeout_height?: number;
                extension_options?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>[];
                non_critical_extension_options?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>[];
            } = {};
            if (this.messages != null) {
                data.messages = this.messages.map((item: dependency_5.google.protobuf.Any) => item.toObject());
            }
            if (this.memo != null) {
                data.memo = this.memo;
            }
            if (this.timeout_height != null) {
                data.timeout_height = this.timeout_height;
            }
            if (this.extension_options != null) {
                data.extension_options = this.extension_options.map((item: dependency_5.google.protobuf.Any) => item.toObject());
            }
            if (this.non_critical_extension_options != null) {
                data.non_critical_extension_options = this.non_critical_extension_options.map((item: dependency_5.google.protobuf.Any) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.messages !== undefined)
                writer.writeRepeatedMessage(1, this.messages, (item: dependency_5.google.protobuf.Any) => item.serialize(writer));
            if (typeof this.memo === "string" && this.memo.length)
                writer.writeString(2, this.memo);
            if (this.timeout_height !== undefined)
                writer.writeUint64(3, this.timeout_height);
            if (this.extension_options !== undefined)
                writer.writeRepeatedMessage(1023, this.extension_options, (item: dependency_5.google.protobuf.Any) => item.serialize(writer));
            if (this.non_critical_extension_options !== undefined)
                writer.writeRepeatedMessage(2047, this.non_critical_extension_options, (item: dependency_5.google.protobuf.Any) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TxBody {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TxBody();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.messages, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_5.google.protobuf.Any.deserialize(reader), dependency_5.google.protobuf.Any));
                        break;
                    case 2:
                        message.memo = reader.readString();
                        break;
                    case 3:
                        message.timeout_height = reader.readUint64();
                        break;
                    case 1023:
                        reader.readMessage(message.extension_options, () => pb_1.Message.addToRepeatedWrapperField(message, 1023, dependency_5.google.protobuf.Any.deserialize(reader), dependency_5.google.protobuf.Any));
                        break;
                    case 2047:
                        reader.readMessage(message.non_critical_extension_options, () => pb_1.Message.addToRepeatedWrapperField(message, 2047, dependency_5.google.protobuf.Any.deserialize(reader), dependency_5.google.protobuf.Any));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TxBody {
            return TxBody.deserialize(bytes);
        }
    }
    export class AuthInfo extends pb_1.Message {
        constructor(data?: any[] | {
            signer_infos?: SignerInfo[];
            fee?: Fee;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("signer_infos" in data && data.signer_infos != undefined) {
                    this.signer_infos = data.signer_infos;
                }
                if ("fee" in data && data.fee != undefined) {
                    this.fee = data.fee;
                }
            }
        }
        get signer_infos() {
            return pb_1.Message.getRepeatedWrapperField(this, SignerInfo, 1) as SignerInfo[];
        }
        set signer_infos(value: SignerInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get fee() {
            return pb_1.Message.getWrapperField(this, Fee, 2) as Fee;
        }
        set fee(value: Fee) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        static fromObject(data: {
            signer_infos?: ReturnType<typeof SignerInfo.prototype.toObject>[];
            fee?: ReturnType<typeof Fee.prototype.toObject>;
        }) {
            const message = new AuthInfo({});
            if (data.signer_infos != null) {
                message.signer_infos = data.signer_infos.map(item => SignerInfo.fromObject(item));
            }
            if (data.fee != null) {
                message.fee = Fee.fromObject(data.fee);
            }
            return message;
        }
        toObject() {
            const data: {
                signer_infos?: ReturnType<typeof SignerInfo.prototype.toObject>[];
                fee?: ReturnType<typeof Fee.prototype.toObject>;
            } = {};
            if (this.signer_infos != null) {
                data.signer_infos = this.signer_infos.map((item: SignerInfo) => item.toObject());
            }
            if (this.fee != null) {
                data.fee = this.fee.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.signer_infos !== undefined)
                writer.writeRepeatedMessage(1, this.signer_infos, (item: SignerInfo) => item.serialize(writer));
            if (this.fee !== undefined)
                writer.writeMessage(2, this.fee, () => this.fee.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AuthInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AuthInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.signer_infos, () => pb_1.Message.addToRepeatedWrapperField(message, 1, SignerInfo.deserialize(reader), SignerInfo));
                        break;
                    case 2:
                        reader.readMessage(message.fee, () => message.fee = Fee.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AuthInfo {
            return AuthInfo.deserialize(bytes);
        }
    }
    export class SignerInfo extends pb_1.Message {
        constructor(data?: any[] | {
            public_key?: dependency_5.google.protobuf.Any;
            mode_info?: ModeInfo;
            sequence?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("public_key" in data && data.public_key != undefined) {
                    this.public_key = data.public_key;
                }
                if ("mode_info" in data && data.mode_info != undefined) {
                    this.mode_info = data.mode_info;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
            }
        }
        get public_key() {
            return pb_1.Message.getWrapperField(this, dependency_5.google.protobuf.Any, 1) as dependency_5.google.protobuf.Any;
        }
        set public_key(value: dependency_5.google.protobuf.Any) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get mode_info() {
            return pb_1.Message.getWrapperField(this, ModeInfo, 2) as ModeInfo;
        }
        set mode_info(value: ModeInfo) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get sequence() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            public_key?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>;
            mode_info?: ReturnType<typeof ModeInfo.prototype.toObject>;
            sequence?: number;
        }) {
            const message = new SignerInfo({});
            if (data.public_key != null) {
                message.public_key = dependency_5.google.protobuf.Any.fromObject(data.public_key);
            }
            if (data.mode_info != null) {
                message.mode_info = ModeInfo.fromObject(data.mode_info);
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            return message;
        }
        toObject() {
            const data: {
                public_key?: ReturnType<typeof dependency_5.google.protobuf.Any.prototype.toObject>;
                mode_info?: ReturnType<typeof ModeInfo.prototype.toObject>;
                sequence?: number;
            } = {};
            if (this.public_key != null) {
                data.public_key = this.public_key.toObject();
            }
            if (this.mode_info != null) {
                data.mode_info = this.mode_info.toObject();
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.public_key !== undefined)
                writer.writeMessage(1, this.public_key, () => this.public_key.serialize(writer));
            if (this.mode_info !== undefined)
                writer.writeMessage(2, this.mode_info, () => this.mode_info.serialize(writer));
            if (this.sequence !== undefined)
                writer.writeUint64(3, this.sequence);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignerInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignerInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.public_key, () => message.public_key = dependency_5.google.protobuf.Any.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.mode_info, () => message.mode_info = ModeInfo.deserialize(reader));
                        break;
                    case 3:
                        message.sequence = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignerInfo {
            return SignerInfo.deserialize(bytes);
        }
    }
    export class ModeInfo extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            single?: ModeInfo.Single;
            multi?: never;
        } | {
            single?: never;
            multi?: ModeInfo.Multi;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1, 2]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("single" in data && data.single != undefined) {
                    this.single = data.single;
                }
                if ("multi" in data && data.multi != undefined) {
                    this.multi = data.multi;
                }
            }
        }
        get single() {
            return pb_1.Message.getWrapperField(this, ModeInfo.Single, 1) as ModeInfo.Single;
        }
        set single(value: ModeInfo.Single) {
            pb_1.Message.setOneofWrapperField(this, 1, [1, 2], value);
        }
        get multi() {
            return pb_1.Message.getWrapperField(this, ModeInfo.Multi, 2) as ModeInfo.Multi;
        }
        set multi(value: ModeInfo.Multi) {
            pb_1.Message.setOneofWrapperField(this, 2, [1, 2], value);
        }
        get sum() {
            const cases: {
                [index: number]: "none" | "single" | "multi";
            } = {
                0: "none",
                1: "single",
                2: "multi"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            single?: ReturnType<typeof ModeInfo.Single.prototype.toObject>;
            multi?: ReturnType<typeof ModeInfo.Multi.prototype.toObject>;
        }) {
            const message = new ModeInfo({});
            if (data.single != null) {
                message.single = ModeInfo.Single.fromObject(data.single);
            }
            if (data.multi != null) {
                message.multi = ModeInfo.Multi.fromObject(data.multi);
            }
            return message;
        }
        toObject() {
            const data: {
                single?: ReturnType<typeof ModeInfo.Single.prototype.toObject>;
                multi?: ReturnType<typeof ModeInfo.Multi.prototype.toObject>;
            } = {};
            if (this.single != null) {
                data.single = this.single.toObject();
            }
            if (this.multi != null) {
                data.multi = this.multi.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.single !== undefined)
                writer.writeMessage(1, this.single, () => this.single.serialize(writer));
            if (this.multi !== undefined)
                writer.writeMessage(2, this.multi, () => this.multi.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ModeInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ModeInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.single, () => message.single = ModeInfo.Single.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.multi, () => message.multi = ModeInfo.Multi.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ModeInfo {
            return ModeInfo.deserialize(bytes);
        }
    }
    export namespace ModeInfo {
        export class Single extends pb_1.Message {
            constructor(data?: any[] | {
                mode?: dependency_4.cosmos.tx.signing.v1beta1.SignMode;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("mode" in data && data.mode != undefined) {
                        this.mode = data.mode;
                    }
                }
            }
            get mode() {
                return pb_1.Message.getField(this, 1) as dependency_4.cosmos.tx.signing.v1beta1.SignMode;
            }
            set mode(value: dependency_4.cosmos.tx.signing.v1beta1.SignMode) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                mode?: dependency_4.cosmos.tx.signing.v1beta1.SignMode;
            }) {
                const message = new Single({});
                if (data.mode != null) {
                    message.mode = data.mode;
                }
                return message;
            }
            toObject() {
                const data: {
                    mode?: dependency_4.cosmos.tx.signing.v1beta1.SignMode;
                } = {};
                if (this.mode != null) {
                    data.mode = this.mode;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.mode !== undefined)
                    writer.writeEnum(1, this.mode);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Single {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Single();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.mode = reader.readEnum();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Single {
                return Single.deserialize(bytes);
            }
        }
        export class Multi extends pb_1.Message {
            constructor(data?: any[] | {
                bitarray?: dependency_2.cosmos.crypto.multisig.v1beta1.CompactBitArray;
                mode_infos?: ModeInfo[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("bitarray" in data && data.bitarray != undefined) {
                        this.bitarray = data.bitarray;
                    }
                    if ("mode_infos" in data && data.mode_infos != undefined) {
                        this.mode_infos = data.mode_infos;
                    }
                }
            }
            get bitarray() {
                return pb_1.Message.getWrapperField(this, dependency_2.cosmos.crypto.multisig.v1beta1.CompactBitArray, 1) as dependency_2.cosmos.crypto.multisig.v1beta1.CompactBitArray;
            }
            set bitarray(value: dependency_2.cosmos.crypto.multisig.v1beta1.CompactBitArray) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get mode_infos() {
                return pb_1.Message.getRepeatedWrapperField(this, ModeInfo, 2) as ModeInfo[];
            }
            set mode_infos(value: ModeInfo[]) {
                pb_1.Message.setRepeatedWrapperField(this, 2, value);
            }
            static fromObject(data: {
                bitarray?: ReturnType<typeof dependency_2.cosmos.crypto.multisig.v1beta1.CompactBitArray.prototype.toObject>;
                mode_infos?: ReturnType<typeof ModeInfo.prototype.toObject>[];
            }) {
                const message = new Multi({});
                if (data.bitarray != null) {
                    message.bitarray = dependency_2.cosmos.crypto.multisig.v1beta1.CompactBitArray.fromObject(data.bitarray);
                }
                if (data.mode_infos != null) {
                    message.mode_infos = data.mode_infos.map(item => ModeInfo.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    bitarray?: ReturnType<typeof dependency_2.cosmos.crypto.multisig.v1beta1.CompactBitArray.prototype.toObject>;
                    mode_infos?: ReturnType<typeof ModeInfo.prototype.toObject>[];
                } = {};
                if (this.bitarray != null) {
                    data.bitarray = this.bitarray.toObject();
                }
                if (this.mode_infos != null) {
                    data.mode_infos = this.mode_infos.map((item: ModeInfo) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.bitarray !== undefined)
                    writer.writeMessage(1, this.bitarray, () => this.bitarray.serialize(writer));
                if (this.mode_infos !== undefined)
                    writer.writeRepeatedMessage(2, this.mode_infos, (item: ModeInfo) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Multi {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Multi();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.bitarray, () => message.bitarray = dependency_2.cosmos.crypto.multisig.v1beta1.CompactBitArray.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.mode_infos, () => pb_1.Message.addToRepeatedWrapperField(message, 2, ModeInfo.deserialize(reader), ModeInfo));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Multi {
                return Multi.deserialize(bytes);
            }
        }
    }
    export class Fee extends pb_1.Message {
        constructor(data?: any[] | {
            amount?: dependency_3.cosmos.base.v1beta1.Coin[];
            gas_limit?: number;
            payer?: string;
            granter?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("gas_limit" in data && data.gas_limit != undefined) {
                    this.gas_limit = data.gas_limit;
                }
                if ("payer" in data && data.payer != undefined) {
                    this.payer = data.payer;
                }
                if ("granter" in data && data.granter != undefined) {
                    this.granter = data.granter;
                }
            }
        }
        get amount() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_3.cosmos.base.v1beta1.Coin, 1) as dependency_3.cosmos.base.v1beta1.Coin[];
        }
        set amount(value: dependency_3.cosmos.base.v1beta1.Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get gas_limit() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set gas_limit(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get payer() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set payer(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get granter() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set granter(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            amount?: ReturnType<typeof dependency_3.cosmos.base.v1beta1.Coin.prototype.toObject>[];
            gas_limit?: number;
            payer?: string;
            granter?: string;
        }) {
            const message = new Fee({});
            if (data.amount != null) {
                message.amount = data.amount.map(item => dependency_3.cosmos.base.v1beta1.Coin.fromObject(item));
            }
            if (data.gas_limit != null) {
                message.gas_limit = data.gas_limit;
            }
            if (data.payer != null) {
                message.payer = data.payer;
            }
            if (data.granter != null) {
                message.granter = data.granter;
            }
            return message;
        }
        toObject() {
            const data: {
                amount?: ReturnType<typeof dependency_3.cosmos.base.v1beta1.Coin.prototype.toObject>[];
                gas_limit?: number;
                payer?: string;
                granter?: string;
            } = {};
            if (this.amount != null) {
                data.amount = this.amount.map((item: dependency_3.cosmos.base.v1beta1.Coin) => item.toObject());
            }
            if (this.gas_limit != null) {
                data.gas_limit = this.gas_limit;
            }
            if (this.payer != null) {
                data.payer = this.payer;
            }
            if (this.granter != null) {
                data.granter = this.granter;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.amount !== undefined)
                writer.writeRepeatedMessage(1, this.amount, (item: dependency_3.cosmos.base.v1beta1.Coin) => item.serialize(writer));
            if (this.gas_limit !== undefined)
                writer.writeUint64(2, this.gas_limit);
            if (typeof this.payer === "string" && this.payer.length)
                writer.writeString(3, this.payer);
            if (typeof this.granter === "string" && this.granter.length)
                writer.writeString(4, this.granter);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Fee {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Fee();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.amount, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_3.cosmos.base.v1beta1.Coin.deserialize(reader), dependency_3.cosmos.base.v1beta1.Coin));
                        break;
                    case 2:
                        message.gas_limit = reader.readUint64();
                        break;
                    case 3:
                        message.payer = reader.readString();
                        break;
                    case 4:
                        message.granter = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Fee {
            return Fee.deserialize(bytes);
        }
    }
}
